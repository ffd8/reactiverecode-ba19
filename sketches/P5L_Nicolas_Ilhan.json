{
  "sketches": [
    {
      "sketchName": "structure_audio_done",
      "sketchCode": "let credits = { \n    \"student_names\": \"Ilhan Zulji, Nicolas Zufferey\", \n    \"recode_artist\": \"Zdenek Sykora\", \n    \"recode_title\": \"Black-and-White Structure (Circles)\", \n    \"recode_year\": 1961 \n} \n\n\nlet tiles = [] //invents an array of \"tiles\"\n\nfunction setup() {\n\tcreateCanvas(windowWidth, windowHeight);\n\n\tlet gridSize = height / 11; //size of the tiles (use fraction of height!)\n\n\tfor(let i = 0; i < width; i += gridSize) { //\n\t\tfor(let j = 0; j < height; j += gridSize) { //\n\t\t\ttiles.push(new Tile(i, j, gridSize)) //pushes new Tile with 3 variables to array, maybe?\n\t\t}\n\t}\n\tsetupAudio();\n}\n\nfunction draw() {\n\tprint(0);\n\t/* audio vars: amp, ampEase, fft, waveform */\n\tupdateAudio();\n\tbackground(0);\n\n\tfor(let i = 0; i < tiles.length; i++) {\n\t\ttiles[i].display(); //this should display the tiles on the x(=i)- and y(=j)-axis, maybe?\n\t\t//add audio logic to trigger refresh tiles[i].refresh();\n\t\tif(amp>400\t){\n\t\t\ttiles[i].refresh()\n\t\t}\n\t\t}\n\n\n}\n\nclass Tile { //makes a class that contains everything to build a tile\n\tconstructor(i, j, s) { //acts as setup for the class\n\t\tthis.x = i\n\t\tthis.y = j\n\t\tthis.s = s\n\t\tthis.layer = createGraphics(this.s, this.s); //creates a layer to cut off overlap\n\t\tthis.refresh()\n\n\n\t}\n\n\tdisplay() { //styles and displays the content of the class\n\t\t//layer.background(255); //just for testing, can be commented out later\n\t\tthis.layer.background(this.backgroundColor) //creates a random background that's either (0) or (255)\n\t\tthis.layer.fill(this.fill1) //creates a random fill that's either (0) or (255)\n\t\tthis.layer.ellipse(this.posel / 2, this.s / 2, this.s)\n\t\tthis.layer.fill(this.fill2)\n\t\tthis.layer.ellipse(this.posel / 2 + this.s, this.s / 2, this.s)\n\t\tangleMode(DEGREES)\n\n\t\t//imageMode(CENTER)\n\t\t//rotate(90)\n\t\timage(this.layer, this.x, this.y) //draws image that contains the layer (similar to a rect (maybe use imageMode(CENTER) to properly rotate?!)\n\t}\n\n\trefresh() {\n\t\tthis.backgroundColor = round(random(1)) * 255\n\t\tthis.layer.noStroke()\n\n\t\tif(this.backgroundColor == 0) {\n\t\t\tthis.fill1 = 255\n\t\t\tthis.fill2 = 255\n\t\t} else {\n\t\t\tthis.fill1 = 0\n\t\t\tthis.fill2 = round(random(1))*255\n\t\t}\n\n\t\tthis.posel = round(random(1)) * this.s\n\t}\n}\n\n/* AUDIO INIT */\nlet mic, fftRaw, fft = [],\n\twaveform = [],\n\tamp = 0.0,\n\tampStereo = {\n\t\tl: 0.0,\n\t\tr: 0.0\n\t},\n\tampEase = 0.0,\n\tnumBins = 512,\n\tbands = 12;\n\nfunction setupAudio() {\n\tuserStartAudio();\n\tmic = new p5.AudioIn();\n\tmic.start();\n\tfftRaw = new p5.FFT(0.75, numBins);\n\tfftRaw.setInput(mic);\n}\n\nfunction updateAudio() {\n\tfftRaw.analyze();\n\tamp = mic.getLevel() * 1000; // average mixed amplitude\n\tampStereo.l = mic.amplitude.getLevel(0) * 500; // average left amplitude\n\tampStereo.r = mic.amplitude.getLevel(1) * 500; // average right amplitude\n\tampEase = ease(amp, ampEase, 0.075); // smooth 'amp'\n\twaveform = fftRaw.waveform(); // array (-1, 1)\n\tfft = fftRaw.logAverages(fftRaw.getOctaveBands(bands)); // array (0, 255)\n}"
    }
  ]
}